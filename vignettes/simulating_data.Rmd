---
title: "Simulating Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulating Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(simGWAS)
library(DiagrammeR)
library(dplyr)
library(reshape2)
library(ggplot2)
library(TwoSampleMR)
set.seed(1)
```

## Introduction

This vignette demonstrates how to use the `sim_mv` function to simulate data a few different types of GWAS data.

## Introduction to `sim_mv`

The `sim_mv` function generates GWAS summary statistics for multiple continuous traits from a linear structural 
equation model encoded as a matrix of direct effects. Variants can be generated with or without LD.
There are also some helper functions for LD-pruning and generating special kinds of direct effect matrices. 

The `sim_mv` function is a wrapper to a more general function `sim_sumstats_lf` which generates summary statistics given 
a latent factor structure for a set of traits. Direct usage of `sim_sumstats_lf` is demonstrated briefly at the end of this vignette.



## Basic Usage

The `sim_mv` function has five required arguments:

+ `N`: The GWAS sample size for each trait. This can be a scalar, vector or matrix (more on this below).
+ `J`: The number of SNPs to simulate (scalar).
+ `h2`: The hertiability of each trait. This can be a scalar or a vector with length equal to the number of traits generated.
+ `pi`: The proportion of all SNPs that have a direct effect on each trait. This can be a scalar or a vector with length equal to the number of traits generated.
+ `G`: The matrix specifying diret effects in the linear SEM. 

In the matrix `G`, the 
$G_{i,j}$ entry specifies the direct effect of variable $i$ on variable $j$. The
diagonal entries of $G$ should be 0. All variables are assumed to have variance 
equal to 1, so $G_{i,j}^2$ is the proportion of variable $j$ variance explained by 
the direct effect of variable $i$. 

For example, the graph below: 

```{r, echo=FALSE, fig.align='center', fig.width = 5}
G <- matrix(c(0, sqrt(0.25), 0, sqrt(0.15), 
              0, 0, 0, sqrt(0.1), 
              sqrt(0.2), 0, 0, -sqrt(0.3), 
              0, 0, 0, 0), nrow = 4, byrow = TRUE)


d <- melt(G) %>%
     filter(value !=0) %>%
     rename(from = Var1, to = Var2)


n <- create_node_df(n = 4, label = c("X", "Y", "Z", "W"), 
                    fontname = "Helvetica", 
                    fontsize = 10, 
                    width = 0.3, 
                    fillcolor = "white", 
                    fontcolor = "black",
                    color = "black", 
                    x = c(0, 1, 1, 2), 
                    y = c(0, -0.5, 1, 0))
e <- create_edge_df(from = d$from, to = d$to, minlen = 1,  color = "black", 
                    label = round(d$value, digits = 3))
g <- create_graph(nodes_df = n, edges_df = e)

render_graph(g)
```

is represented by the matrix

```{r}
G <- matrix(c(0, sqrt(0.25), 0, sqrt(0.15), 
              0, 0, 0, sqrt(0.1), 
              sqrt(0.2), 0, 0, -sqrt(0.3), 
              0, 0, 0, 0), nrow = 4, byrow = TRUE)
colnames(G) <- row.names(G) <- c("X", "Y", "Z", "W")
G
```

To simulate data from this graph, we can use

```{r}
sim_dat1 <- sim_mv(G = G,
                  N = 80000, J = 50000, 
                  h2 = c(0.3, 0.3, 0.5, 0.4), 
                  pi = 800/50000)
```

In the function call above, we specified a GWAS sample size of 60k for every GWAS with no overlap. 
We gave different heritabilities of each of the four traits (the `h2` argument). 
Every trait has 1000 direct effect SNPs (the `pi` argument). `J` specifies the total number
of variants to generate. 

### Generating $G$ from "XYZ" mode.

The function `xyz_to_G` will generate a matrix, $G$, corresponding to a specific DAG form. 
In the "XYZ" DAG, 
there is an exposure ($X$), an outcome ($Y$), and $K$ other variables, $Z_1, \dots, Z_K$. 

There is a (possibly 0) effect of $X$ on $Y$ specified by the `beta` argument. 
Variables $Z_1, \dots, Z_K$ can have effects either on or from $X$, $Y$ or both. So
$Z_k$ could be a confounder of $X$ and $Y$ (effects on both variables), a child (collider) of
$X$ and $Y$ (effects from both variables), or a mediator between $X$ and $Y$ (effect from $X$ and to $Y$). 
The program will give an error if the user tries to specify a mediator between $Y$ and $X$ as this would 
create a cycle.
As special cases, any of these effects could be zero. So $Z_k$ could also be a parent only or child only of $X$ or $Y$. 

Effects between each $Z_k$ and $X$ and $Y$ respectively are given in the `tau_xz` and `tau_yz` arguments. 
The direction of these effects is given in the `dir_xz` and `dir_yz` arguments. 
Effect size arguments `beta`, `tau_xz`, and `tau_yz` are all given as signed proportion of variance explained. 
So if `gamma = -0.3`, The direct effect of $X$ explains 30\% of the variance of $Y$ and the 
effect of $X$ on $Y$ is negative. The direction parameters `dri_xz` and `dir_yz` should
have equal length to `tau_xz` and `tau_yz`. Elements should be 1 if there is an effect on $X$ or $Y$ and -1 if there is an effect from $X$ or $Y$. 

For example, the code

```{r}
myG <- xyz_to_G(tau_xz = c(0.1, -0.15, 0.2, 0.3), 
                   tau_yz = c(0, 0.2, -0.25, 0.15), 
                   dir_xz = c(1, 1, -1, -1), 
                   dir_yz = c(1, 1, -1, 1),
                   beta = 0.3)
```

generates the matrix corresponding to the graph below:


```{r, echo=FALSE, fig.align='center', fig.width = 5}

d <- melt(myG) %>%
     filter(value !=0) %>%
     rename(from = Var1, to = Var2)

n <- create_node_df(n = 6, label = c("Y", "X", "Z1", "Z2", "Z3", "Z4"), 
                    fontname = "Helvetica", 
                    fontsize = 10, 
                    width = 0.3, 
                    fillcolor = "white", 
                    fontcolor = "black",
                    color = "black", 
                    x = c(0, 2, -0.5, 1, 1, 1), 
                    y = c(0, 0, 1, 1, -0.5, -1))
e <- create_edge_df(from = d$from, to = d$to, minlen = 1,  color = "black", 
                    label = round(d$value, digits = 3))
g <- create_graph(nodes_df = n, edges_df = e)

render_graph(g)
```


The weights in the graph give the effect size. Note that this is the square root of the value provided in `tau_xz` and `tau_yz` which specifies the percent variance explained. For example, the effect of $Z_1$ on $X$ is  $0.316 = \sqrt{0.1}$ and the effect of $Z_2$ on $X$ is $-0.387 = - \sqrt{0.15}$. 



### Simulation Object

The `sim_mv` function returns a list with the following elements

+ `beta_hat`, `se_beta_hat`: Simulated GWAS effect estimates and standard errors
+ `direct_SNP_effects_marg`: direct effects of SNPs on traits (marginal). Direct here means not mediated by other traits.
+ `direct_SNP_effects_joint`: direct effects of SNPs on traits (joint). Joint and marginal effects 
are the same if there is no LD. With LD, the joint effects are the direct causal effect of the SNP on the trait
while the marginal effect includes LD.
+ `beta_joint` and `beta_marg`: Total associations (including those mediated by other trais). `beta_marg` is the expected value of `beta_hat`.
+ `R`: Correlation in standard errors across traits. This is the identity if there is no
sample overlap. Otherwise it depends on supplied environmental correlation, the genetic 
correlation and the sample overlap. 
+ `direct_trait_effects`: Matrix of direct effects between traits
+ `total_trait_effects`: Matrix of total effects between traits

When used in general mode, the order of the columns in `beta_hat`, `se_beta_hat`, and `B` corresponds
to the order of variables in `G`. When used in xyz mode, the first column is $X$, the second 
column is $Y$ and subsequent columns are the $Z_k$'s in the order they were provided.

### Simulating Data with LD

The function can be used to generate data with LD by inputting a list of LD matrices and a corresponding table of SNP information. The function will work fastest if the LD matrix is broken into small blocks. For this example we will use the LD pattern estimated from Chromosome 19 in HapMap3 which can be downloaded [here](https://zenodo.org/record/6761943#.Yrno2njMIUE). The function currently requires you to input a list of eigen decomposition generated by `eigen` applied to each block in the LD matrix. This is the format of the linked file. These are also available as built-in data objects.

Download the LD data and put them in a directory called `data`. If you save the files with different names, you will need to change the code below. Code in this section is not executed during vignette building due to reliance on external data. 

Let's look at the LD data

```{r, eval = FALSE}
data("ld_evd_list")
data("snpdata")
length(ld_evd_list)
#[1] 39
names(ld_evd_list[[1]])
#[1] "values"  "vectors"
dim(ld_evd_list[[1]]$vectors)
#[1] 140 140
```

We can see that there are 39 LD blocks and the first block as 140 SNPs. 

```{r, eval = FALSE}
# This prints the number of SNPs in each block
purrr::map(ld_evd_list, "values") %>% sapply(length) %>% unlist()
#[1] 140 519 339 435 523 280 675 325 651 548 274 483 442 744 460 177 469 173 358 564 392 737 596 818 307 863 276 435 204 364 480 381 757 844 753 656 483 856 709

purrr::map(ld_evd_list, "values") %>% sapply(length) %>% unlist() %>% sum()
#[1] 19490
dim(snpdata)
#[1] 19490    14
```

We see that in total there are 19,490 SNPs and this is also the number of rows in the SNP information table. If this is not the case, you will get an error. 

```{r, eval = FALSE}
head(snpdata)
# A tibble: 6 × 14
#     AF SNP        allele   chr ld_snp_id       map    pos region_id   snp_id in_hapmap ldscore_1kg ldscore_hm3 keep_ld_prune_0.1 keep_ld_prune_0.01
#  <dbl> <chr>      <chr>  <int>     <int>     <dbl>  <int>     <dbl>    <int> <lgl>           <dbl>       <dbl> <lgl>             <lgl>             
#1 0.394 rs8100066  G,A       19  75034188 0         260912         1 75034188 TRUE             93.0        7.50 FALSE             FALSE             
#2 0.455 rs8102615  A,T       19  75034190 0.0000268 260970         1 75034190 TRUE             81.4        7.03 FALSE             TRUE              
#3 0.394 rs8105536  A,G       19  75034192 0.0000559 261033         1 75034192 TRUE             93.0        7.51 FALSE             FALSE             
#4 0.939 rs2312724  T,C       19  75034339 0.00237   266034         1 75034339 TRUE             16.2        1.89 FALSE             FALSE             
#5 0.399 rs1020382  C,T       19  75034365 0.00283   267039         1 75034365 TRUE             86.8        7.37 FALSE             FALSE             
#6 0.343 rs12459906 T,C       19  75034615 0.00709   276245         1 75034615 TRUE             79.3        7.52 FALSE             FALSE             
```

This SNP information table has many columns but the only required columns are `SNP` giving a SNP name (can be arbitrary) and `AF` giving the allele frequency. Since we have only provided 19k SNPs but may wish to generate many more, the function will simply repeat this LD pattern as many times as necessary to give the desired number of variants. To generate data with LD, these two objects are given to the `R_LD` and `snp_info` parameters. Most likely, you will want to generate more variants when using LD than when not using LD. This takes longer than generating independent data. 

```{r, eval = FALSE}
sim_dat1_LD <- sim_mv(G = G,
                  N = 80000, J = 100000, 
                  h2 = c(0.3, 0.3, 0.5, 0.4), 
                  pi = 800/50000, R_LD = ld_evd_list, 
                  snp_info = snpdata)
```

You will notice that in data with LD, there are fewer exact zeros in `direct_SNP_effects`. This is a direct result of LD, as `direct_SNP_effects` reports the true association of each SNP with each trait that is not mediated by other traits. One useful column of `snpdata` is the `keep_ld_prune_0.1` column which indicates SNPs that are independent with mutual$R^2$ less than 0.1 (similar for `keep_ld_prune_0.01`). The returned data has a copy of the table passed to `snp_info` expanded to match all SNPs. Thus if we want to identify an LD-pruned set of variants, we can use this column rather than LD pruning.

```{r, eval = FALSE}
dim(sim_dat1_LD$snp_info)
#[1] 100000     16
head(sim_dat1_LD$snp_info)
# A tibble: 6 × 16
#      AF SNP          allele   chr ld_snp_id       map    pos region_id   snp_id in_hapmap ldscore_1kg ldscore_hm3 keep_ld_prune_0.1 keep_ld_prune_0.01 block   rep
#   <dbl> <chr>        <chr>  <int>     <int>     <dbl>  <int>     <dbl>    <int> <lgl>           <dbl>       <dbl> <lgl>             <lgl>              <int> <dbl>
# 1 0.394 rs8100066.1  G,A       19  75034188 0         260912         1 75034188 TRUE             93.0        7.50 FALSE             FALSE                  1     1
# 2 0.455 rs8102615.1  A,T       19  75034190 0.0000268 260970         1 75034190 TRUE             81.4        7.03 FALSE             TRUE                   1     1
# 3 0.394 rs8105536.1  A,G       19  75034192 0.0000559 261033         1 75034192 TRUE             93.0        7.51 FALSE             FALSE                  1     1
# 4 0.939 rs2312724.1  T,C       19  75034339 0.00237   266034         1 75034339 TRUE             16.2        1.89 FALSE             FALSE                  1     1
# 5 0.399 rs1020382.1  C,T       19  75034365 0.00283   267039         1 75034365 TRUE             86.8        7.37 FALSE             FALSE                  1     1
# 6 0.343 rs12459906.1 T,C       19  75034615 0.00709   276245         1 75034615 TRUE             79.3        7.52 FALSE             FALSE                  1     1
indep_vars = which(sim_dat1_LD$snp_info$keep_ld_prune_0.1 == TRUE)
length(indep_vars)
#[1] 13611
```

In this case, out of 100k variants, we have a subset of 13k that are approximately independent. 


### Exploring MR with simulations

We will use the data generated without LD to explore MR. 
Suppose we are interested in estimating the effect of $X$ on $W$. The total effect of 
$X$ on $W$ is $0.387 + 0.5\cdot 0.316 = 0.545$. We can confirm this by looking at the (1,4) element of
`total_trait_effects` matrix:

```{r}
sim_dat1$total_trait_effects
```

Valid instruments for measuring this effect are SNPs that have non-zero direct
effect on $X$ but zero direct effect on all other SNPs. Note that direct effects
are assigned randomly, so by chance some SNPs will have direct effects on more than one trait. 


Before we try to apply MR, let's take a look at the **true** total effects of each SNP on $X$ 
plotted against the **true** total effect of each SNP on $Y$. We will color SNPs by 
which of the four variables they directly effect. These categories are tabulated below. We will not plot
the null SNPs (SNPs with no effects on any variables) since these SNPs all correspond
to a point at the origin (recall we are plotting the true effects and not the effect estimates). 

```{r}
te <- data.frame(x_effect = sim_dat1$beta_marg[,1], 
                 w_effect = sim_dat1$beta_marg[,4], 
                 type = case_when(rowSums(sim_dat1$direct_SNP_effects_marg !=0) == 0 ~ "Null SNPs",
                                  (sim_dat1$direct_SNP_effects_marg[,1] != 0 & 
                                    rowSums(sim_dat1$direct_SNP_effects_marg[,-1] !=0) == 0) ~ "X Effect SNPs", 
                                  (sim_dat1$direct_SNP_effects_marg[,3] != 0 & 
                                    rowSums(sim_dat1$direct_SNP_effects_marg[,-3] !=0) == 0) ~ "Z Effect SNPs",
                                  (sim_dat1$direct_SNP_effects_marg[,2] != 0 & 
                                    rowSums(sim_dat1$direct_SNP_effects_marg[,-2] !=0) == 0) ~ " Y Effect SNPs", 
                                  (sim_dat1$direct_SNP_effects_marg[,4] != 0 & 
                                    rowSums(sim_dat1$direct_SNP_effects_marg[,-4] !=0) == 0) ~ " W Effect SNPs", 
                                  TRUE ~ "Multiple"))
table(te$type)
```
Below is the plot of the true effects on $X$ vs true effects on $W$. The black line has slope 
equal to the total effect of $X$ on $W$ which we are trying to estimate. 

```{r, fig.width=6}
te %>% filter(type != "Null SNPs") %>%
ggplot() + 
  geom_point(aes(x = x_effect, y = w_effect, color = type), alpha = 0.6) + 
  geom_abline(slope = sim_dat1$total_trait_effects[1,4]) + 
  theme_bw()

```

Notice the following features of the graph: 

+ The SNPS with direct effects on $X$ *only* fall exactly along the black line. 
+ SNPs with direct effects on $Z$ only (the confounder of $X$ and $W$) fall on a different line. 
+ SNPS with direct effects on $W$ or $Y$ only fall on the x-axis -- they have no effect on $X$. 
+ SNPs with direct effects on multiple traits are scattered around the plot. 

Look at the DAG for this data and verify for yourself why each of these features should be true. 

This plot shows us that, if we want to estimate the effect of $X$ on $W$, we should use SNPs that affect $X$ only. If we also include SNPs with direct effects on $Z$, we will not be able to 
estimate the slope of the black line. We will see this below.

### Single Variable MR

A typical MR workflow might involve first selecting SNPs that are strongly associated with $X$ and then fitting single-variable MR. With this data, we expect this approach to be biased due to the heritable confounder $Z$. The plot below shows the effect estimates for SNPs selected according to their association p-value with $X$. Note that this data set was generated with large SNP effects and large sample size in order to better visualize the effects.  

```{r, fig.width=6}
# Dataframe of effect estimates
est_eff <- data.frame(bhat_x = sim_dat1$beta_hat[,1], 
                      bhat_w = sim_dat1$beta_hat[,4], 
                      se_bhat_x = sim_dat1$se_beta_hat[,1], 
                      se_bhat_w = sim_dat1$se_beta_hat[,4]) %>%
           mutate(p_val_x = 2*pnorm(-abs(bhat_x/se_bhat_x)))
est_eff$type <- te$type

# Variants we select for single-variable MR
sv_mr_inst <- filter(est_eff, p_val_x < 5e-8)

sv_mr_inst %>% 
ggplot() + 
  geom_point(aes(x = bhat_x, y = bhat_w, color = type), alpha = 0.6) + 
  theme_bw()
```

Next we fit single-variable MR using both all selecte instruments and restricting 
to only valid instruments (instruments with direct effects only on $X$). 

```{r}
mr_res1 <- mr_ivw(b_exp = sv_mr_inst$bhat_x, b_out = sv_mr_inst$bhat_w, 
       se_exp = sv_mr_inst$se_bhat_x, se_out = sv_mr_inst$se_bhat_w)

sv_mr_inst_xonly <- filter(est_eff, p_val_x < 5e-8 & type == "X Effect SNPs")
mr_res2 <- mr_ivw(b_exp = sv_mr_inst_xonly$bhat_x, b_out = sv_mr_inst_xonly$bhat_w, 
       se_exp = sv_mr_inst_xonly$se_bhat_x, se_out = sv_mr_inst_xonly$se_bhat_w)
```

The plot below shows the naive single-variable MR estimate (red), the estimate using only X effect SNPs (blue), and the truth (black). Dotted lines correspond to 95\% confidence intervals. 

```{r,  fig.width=6}
mr_slope <- data.frame(slope = c(mr_res1$b, 
                                 mr_res2$b, 
                                 sim_dat1$total_trait_effects[1,4]), 
                        col = c("red", "blue", "black"), 
                       lty = 1)

ci_slope <- data.frame(slope = c(mr_res1$b + c(-1, 1)*mr_res1$se*qnorm(0.975), 
                                 mr_res2$b + c(-1, 1)*mr_res2$se*qnorm(0.975)), 
                       col = rep(c("red", "blue"), each = 2), 
                       lty = 2)
mr_slope <- bind_rows(mr_slope, ci_slope)

sv_mr_inst %>% 
ggplot() + 
  geom_point(aes(x = bhat_x, y = bhat_w), alpha = 0.6) + 
  geom_abline(slope = mr_slope$slope, color = mr_slope$col, linetype = mr_slope$lty)

```

```{r}
sv_res <- data.frame(est = c(mr_res1$b, mr_res2$b, sim_dat1$total_trait_effects[1,4]), 
                     ci_lower = c(mr_res1$b-mr_res1$se*qnorm(0.975), 
                                  mr_res2$b-mr_res2$se*qnorm(0.975), 
                                  NA), 
                     ci_upper = c(mr_res1$b+mr_res1$se*qnorm(0.975), 
                                  mr_res2$b+mr_res2$se*qnorm(0.975), 
                                  NA),
                     type = c("Naive", "Valid Instruments Only", "Truth"))
sv_res
```


Note that even using only valid instruments, the estimate is still slightly low, which is a result of weak instrument bias. 



